# YAZILIM-GELİSTİRME DONGUSU
SDLC VE SCRUM
YAZILIM GELİŞTİRME YAŞAM DÖNGÜSÜ  (SDLC)
ÖZET
Geliştirilen bir yazılımın planlanmasından başlanmak üzere teslimat anına kadar geçirilen tüm evreler ve bu evrelerden meydana gelen döngüye denmektedir. Bir yazılım projesi geliştirilmesinde yalnızca kodlama bulunmamaktadır. Bir proje geliştirirken planlama, analiz, tasarım ve test evreleri vardır. Bu evreler bir kere gerçekleştiğinde ilgili proje yarım kalabilmektedir. Bu evrelerin bir döngü şeklinde gerçekleşmesi gerekmektedir. Proje bitmiş olsa bile talepler doğrultusunda hata düzeltmesi, eklenecek yeni modüller ya da konular için süreç sürmektedir. Bu süreç yazılım yaşam döngüsü adını almaktadır.

SDLC

Bir yazılım yaşam döngüsü modeli (süreç modeli olarak da adlandırılır), yazılım yaşam döngüsünün resimli ve şematik bir temsilidir. Bir yaşam döngüsü modeli, bir yazılım ürününün yaşam döngüsü aşamaları boyunca geçişini sağlamak için gereken tüm yöntemleri temsil eder. Ayrıca, bu yöntemlerin gerçekleştirileceği yapıyı da yakalar.Başka bir deyişle, bir yaşam döngüsü modeli, bir yazılım ürünü üzerinde başlangıcından kullanımdan kaldırılmasına kadar gerçekleştirilen çeşitli aktivitelerin haritasını çıkarır. Farklı yaşam döngüsü modelleri, gerekli geliştirme faaliyetlerini farklı şekillerde aşamalara planlayabilir. Böylece, yaşam döngüsü modelinde izlenen hiçbir unsur yoktur, eylem farklı yaşam döngüsü modellerinde farklı sıralarda gerçekleştirilebilse de, tüm yaşam döngüsü modellerinde temel faaliyetler bulunur. Herhangi bir yaşam döngüsü aşamasında, birden fazla aktivite de gerçekleştirilebilir. Geliştirme ekibi, belirli bir plan için uygun bir yaşam döngüsü modeli belirlemeli ve ardından bunu gözlemlemelidir.Kesin bir yaşam döngüsü modeli kullanılmadan, bir yazılım ürününün geliştirilmesi sistematik ve disiplinli bir şekilde olmaz. Bir ekip bir yazılım ürünü geliştirirken, ekip temsilcisi arasında ne zaman ve ne yapılacağı konusunda net bir anlayış olmalıdır. Aksi takdirde kaosa ve proje başarısızlığına işaret eder. Bir yazılım yaşam döngüsü modeli, her aşama için giriş ve çıkış kriterlerini tanımlar. Bir aşama, ancak aşamaya giriş kriterleri yerine getirilmişse başlayabilir. Dolayısıyla bir yazılım yaşam döngüsü modeli olmadan bir aşamanın giriş ve çıkış kriterleri tanınamaz. Yazılım yaşam döngüsü modelleri olmadan, yazılım proje yöneticilerinin projenin ilerlemesini izlemesi zorlaşır.Yazılım yaşam döngüleri aşamaları şunlardır:Planlama ve ihtiyaç analizi,gereksinimlerin tanımlanması,yazılımın tasarlanması,projenin geliştirilmesi,test etme,dağıtım,bakım.Planlama ve ihtiyaç analizi,yazılım yaşam döngüsündeki en önemli aşamadır. Ekibin kıdemli üyeleri, bunu sektördeki tüm paydaşlardan ve alan uzmanlarından veya KOBİ'lerden gelen girdilerle gerçekleştirir.Kalite güvence gereksinimlerinin planlaması ve projelerle ilgili risklerin belirlenmesi de bu aşamada yapılır.İş analisti ve Proje organizatörü, müşterinin inşa etmek istediği, son kullanıcının kim olacağı, ürünün amacı ne olduğu gibi tüm verileri toplamak için müşteriyle bir toplantı ayarladı. Bir ürün yaratmadan önce, ürünle ilgili temel bir anlayış veya bilgi çok gereklidir.Gereksinimlerin tanımlanması, Gereksinim analizi yapıldıktan sonraki aşama, yazılım gereksinimlerinin kesin olarak temsil edilmesi, belgelenmesi ve proje paydaşlarından kabul edilmesidir.Bu, proje yaşam döngüsü boyunca oluşturulacak ve geliştirilecek tüm ürün gereksinimlerini içeren "SRS" - Yazılım Gereksinim Belirtimi belgesi ile gerçekleştirilir.Yazılım tasarlanması, bir sonraki aşama, yazılım projesinin tüm gereksinimleri, analizi ve tasarımı bilgilerini aşağı çekmek üzeredir. Bu aşama, müşteriden gelen girdiler ve gereksinim toplama gibi son ikisinin ürünüdür.Projenin geliştirilmesi,yazılım geliştirme yaşam döngüsünün bu aşamasında, asıl geliştirme başlar ve programlama yapılır. Tasarımın uygulanması, kod yazma ile başlar. Geliştiriciler, yönetimleri tarafından açıklanan kodlama yönergelerini takip etmelidir ve kodu geliştirmek ve uygulamak için derleyiciler, yorumlayıcılar, hata ayıklayıcılar vb. gibi programlama araçları kullanılır.Test etme, kod oluşturulduktan sonra, ürünlerin gereksinimler aşamasında ele alınan ve toplanan ihtiyaçları çözdüğünden emin olmak için gereksinimlere karşı test edilir.Bu aşamada birim testi, entegrasyon testi, sistem testi, kabul testi yapılır.Dağıtım, yazılım onaylandıktan ve herhangi bir hata veya hata belirtilmedikten sonra dağıtılır.Ardından, değerlendirmeye dayalı olarak, yazılım olduğu gibi veya nesne segmentinde önerilen geliştirme ile yayınlanabilir.Yazılım dağıtıldıktan sonra bakımı başlar.Bakım, müşteri geliştirilen sistemleri kullanmaya başladığında, zaman zaman gerçek sorunlar ve çözülmesi gereken gereksinimler ortaya çıkar.Geliştirilen ürüne özen gösterildiği bu işleme denir.

1)GELİŞİGÜZEL MODEL:

Bu yöntemi bir model olarak tanımlamak doğru değildir.Herhangi bir model veya yöntem gözetmeksizin yapılır.İlgi duyan veya geliştiren kişiye bağımlıdır.Bu yüzden yazılımın takip edilebilirliği ve bakımı oldukça zordur.Maidı olarak 60’lı yıllarda kalmıştır.Ekseriyetle tek kişilik üretim ortamı vardır.Çok basit programlamaya sahiptir.

2)BAROK MODELİ:

1970'li Yılların ortalarında ortaya çıkan bu model yaşam döngüsünün temel adımlarını doğrusal bir biçimde gerçekleştirmeyi öngörmektedir. Modelin en önemli özelliği ise belgeleme olgusunu ayrı bir süreç olarak ele almasıdır. Belgeleme sürecini yazılım geliştirme aşamasından sonra yapılmasını ele almıştır. Günümüzde belgeleme her süreçte kullanırken sadece 1 aşama olarak ele alınması modelin zayıf yönlerindendir. Ayrıca model de geri dönüşler hakkında bilgiler verilmemesi de eksi yönlerinden bir tanesidir.

3)ŞELALE MODELİ:

Şelale Modeli doğrusal bir ardışık akıştır. Yazılım uygulamasının aşamaları boyunca ilerlemenin (bir şelale gibi) istikrarlı bir şekilde aşağıya doğru aktığı görülüyor. Bu, geliştirme sürecindeki herhangi bir aşamanın ancak önceki aşama tamamlandığında başlayacağı anlamına gelir. Şelale yaklaşımı, gereksinimdeki değişiklikleri ele almak için önceki aşamaya geri dönme sürecini tanımlamaz. Şelale yaklaşımı, yazılım geliştirme için kullanılan en eski ve en yaygın olarak bilinen yaklaşımdır. Gereksinimleri değiştirmeye odaklanmayan projeler için, örneğin bir teklif talebinden (RFP'ler) başlatılan projeler için, müşterinin çok net belgelenmiş gereksinimleri vardır.Avantajarı, Kullanıcılara açıklamak kolaydır.Aşamalar ve faaliyetler iyi tanımlanmıştır.Projenin planlanmasına ve programlanmasına yardımcı olur.Her aşamada doğrulama, hataların/yanlış anlamaların erken tespit edilmesini sağlar.Her aşamanın belirli çıktıları vardır.Dezavantajları, Bir sistemin gereksinimlerinin dondurulabileceğini varsayar.Bitirdikten sonra herhangi bir aşamaya geri dönmek çok zor.Biraz esneklik ve kapsamı ayarlamak zor ve pahalıdır.Ayrıntılı plana ek olarak maliyetli ve daha fazla zaman gerektirir.

4)ÇAĞLAYAN YAŞAM MODELİ:

Çağlayan yaşam modeli geçmişte en popüler yazılım geliştirme modeli olarak görülmüştür. En eski, en tanınmış ve en temel modeldir.Geleneksel yazılım geliştirme modeli olarak da bilinir. Çağlayan yaşam modelin de yazılım, aşamaların en az birer kez tekrarlanması ile geliştirilir. Çok iyi tanımlanmış ve üretimi az zaman gerektiren projeler için uygun bir model olmakla birlikte günümüzde kullanımı gittikçe azalmaktadır.Çağlayan yaşam modelinde, işler aşama aşama yapılır. Bir aşama bitmeden diğer aşamaya geçilmez. Her safhada dokümantasyon yazılmalıdır. Her şeyin dokümanının olması gerekir. Eğer bir safhada dokümantasyon ve test olmamışsa, o safhanın tamamlandığı kabul edilmez. Çağlayan yaşam-döngü modeli ,Barok modelinden farklı olarak proje içerisindek idokümantasyonu ayrı bir süreç olarak değil üretimin doğal bir parçası olarak ele alır.Ayrıca,bu modelde aşamal ararasındaki geri dönüşlerin nasıl olacağıda tanımlıdır.Ancak,çağlayan yaşam-döngü modelinin kullanımında dikkat edilmesi gereken önemli hususlar vardır.Bunlardan en önemlisi, her ne kadar model içerisinde aşamalar arasında geri dönüşler yapılabilsede analiz aşamasında mümkün olan tüm detayın tasarıma yansıtılabilmesi için müşteri ve sistem gereksinimlerinin en ince ayrıntısına kadar belirlenmesi gerekir. Tasarım aşamasıda, yazılımın tüm gereksinimlerini karşılayacak şekilde detaylı bir çalışma gerektirmektedir.Dolayısı ile,çağlayan yaşam-döngü modelini kullanan proje ekipleri en fazla zamanı bu iki aşamada harcamak zorundadırlar. Tüm bu efor ve detaylı çalışmalara rağmen özellikle uzun zamana yayılan projelerde gereksinimlerin değişecek olması kaçınılmazdır.Kodlama veya test aşamalarında olabilecek bu değişikliklerin sisteme/yazılıma yansıtılması maliyeti ise çok yüksektir. Gerçek yaşamdaki projeler genelde yineleme gerektirir. Genelde yazılımın kullanıcıya ulaşma zamanı uzundur. Gereksinim tanımlamaları çoğu kez net bir şekilde yapılamadığından dolayı,yanlışların düzeltilme ve eksiklerin giderilme maliyetleri yüksektir. Yazılım üretim ekipleri bir an önce program yazma, çalıştırma ve sonucu görme eğiliminde olduklarından,bu model ile yapılan üretimlerde ekip mutsuzlaşmakta ve kod yazma dışında kalan kesime önem vermemektedirler.Kullanıcı,sürecinin içerisinde yer almaz ve bu durum yazılım tamamlandıktan sonra geri dönüşleri arttırabilir.Bu geri dönüşler,yazılım geliştirme maliyetini büyük oranda yükselten bir durumdur.

5)V MODELİ:

Şelale modelinin bir uzantısıdır, Doğrusal bir şekilde aşağı hareket etmek yerine, tipik V şeklini oluşturmak için uygulama ve kodlama aşamasından sonra işlem adımları yukarı doğru bükülür. V şekilli model ile şelale modeli arasındaki en büyük fark, V şekilli modeldeki erken test planlamasıdır. Açıkça tanımlanmış ve bilinen yazılım gereksinimleridir.Yazılım geliştirme teknolojileri ve araçları iyi bilinmektedir.V süreç modelinin temel  çıktıları kullanıcı  modeli ,mimari model , gerçekleştirim modelidir. Kullanıcı modelinde, geliştirme sürecinin kullanıcı ile olan ilişkileri tanımlanmakta ve sistemin nasıl kabul edileceğine ilişkin sınama belirtimleri ve planları ortaya çıkarılmaktadır. Mimari modelinde ise sistem tasarımı ve oluşacak alt sistem ile tüm sistemin sınama işlemlerine ilişkin işlevler belirlenir. Gerçekleştirim modelinde, yazılım modüllerinin kodlanması ve sınanmasına ilişkin fonksiyonlar halledilir. Avantajları, Basit ve kullanımı kolaydır.Her aşamanın belirli çıktıları vardır.Yaşam döngüsünün başlarında test planlarının geliştirilmesi nedeniyle şelale modeline göre daha yüksek başarı şansı,gereksinimlerin kolayca anlaşıldığı yerlerde iyi çalışır,ürün geliştirmenin ilk aşamalarında ürünün doğrulanması ve onaylanması.Dezavantajları, şelale modeli gibi çok esnek değil.Kapsamı ayarlamak zor ve pahalıdır. Yazılım, uygulama aşamasında geliştirilir, bu nedenle yazılımın erken prototipleri üretilmez. Model, test aşamalarında bulunan sorunlar için net bir yol sağlamaz.Ayrıntılı bir plana ek olarak maliyetli ve daha fazla zaman gerektiren bir modeldir.

6)HELEZONİK(SPİRAL)MODEL:

Yukarıdan aşağıya ve aşağıdan yukarıya kavramların avantajlarını birleştirmek amacıyla hem tasarım hem de aşamalarda prototip oluşturma unsurlarını birleştiriyor. Bu geliştirme modeli, prototipleme modelinin ve şelale modelinin özelliklerini birleştirir. Spiral model, büyük, pahalı ve karmaşık projeler için tercih edilir. Bu model, şelale modeliyle aynı aşamaların çoğunu, temelde aynı sırada, planlama, risk değerlendirmesi ve prototiplerin ve simülasyonların oluşturulmasıyla ayrılır. Küçük fazlar veya segmentler içeren büyük uygulamalarda ve sistemlerde kullanılır.Helezonik model döngülere  ayrılmıştır.Bu döngüler  planlama,risk analizi,üretim,kullanıcı değerlendirmesidir.  Planlama,üretilecek ara ürün için planlama, amaç belirleme, bir önceki adımda üretilen ara ürün ile bütünleştirmedir.Risk Analizi,risk seçeneklerinin araştırılması ve risklerin belirlenmesidir.Üretim,ara ürünün üretilmesidir.Kullanıcı Değerlendirmesi,ara ürün ile ilgili olarak kullanıcı tarafından yapılan sınama ve değerlendirmelerdir.Bu modelde risk analizi olgusu ön plana çıkmıştır. Doğrudan gereksinim, analiz, tasarım,... vs. gibi bir faz yoktur.Yinelemeli artımsal bir yaklaşım vardır.Prototip yaklaşımı vardır. Avantajarı, tahminler (yani bütçe, program vb.), önemli konular daha erken keşfedildiği için iş ilerledikçe daha gerçekçi hale gelir.Geliştiricilerin erken katılımı. Sağlanır.Riskleri yönetir ve sistemi aşamalar halinde geliştirir.Dezavantajarı, nihai ürüne ulaşmak için yüksek maliyet ve zaman gerekir.Riskleri ve varsayımları değerlendirmek için özel becerilere ihtiyaç duyar.

7) ARITIMSAL GELİŞTİRME SÜREÇ MODELİ:
8) 
Sistemi tek seferde teslim etmek yerine, geliştirme ve teslim parçalara bölünür. Her teslim beklenen işlevselliğin bir parçasını karşılar. Kullanıcı gereksinimleri önceliklendirilir ve öncelikli gereksinimler erken teslimlere dahil edilir. Gereksinimler önemlerin eve birbirine bağımlılıklarına göre sıralanarak her yinelemede bunların bir kısmı tamamlanır. Bir parçanın geliştirmesi başladığında, gereksinimleri dondurulur. Olası değişiklikler sonraki teslimlerde ele alınır. Üretilen her yazılım sürümü birbirini kapsayacak ve giderek artan sayıda işlev içerecek şekilde geliştirilir. Uzun zaman alabilecek ve  sistemin eksik işlevsellikle çalışabileceği türdeki projeler bu modele uygun olabilir. Bir taraftan kullanım, diğer taraftan üretim yapılır. Artımsal geliştirme yaşam-döngü modelindeki temel süreç akışı : Genel gereksinim belirlenmesi, gereksinimleri artırımlara bölme,sistem mimarisini tanımlama sistem artırılmasının yapılması,artırılımın onaylanması,artırılımın birleştirilmesi,sistemin onaylanması şeklindedir. Yazılım geliştirme iteratif bir süreçtir. Her süreçte sonuca biraz daha yaklaşılmaktadır.Tekrar olmadan yazılım mühendisliği çalışmaz. Her teslimle birlikte müşteriye görünen bir değer döndüğünden, sistemin işlevselliği erken aşamalarda ortaya çıkar. Erken teslimler, sonraki teslimler için gereksinimleri çıkarmada prototip vazifesi görür. Projenin tümden batması riskini azaltır. Öncelikli gereksinimleri karşılayan sistem işlevleri daha çok test edilir.

8)KODLA VE DÜZELT YAŞAM DÖNGÜ MODELİ:

Birkaç yüz satırdan oluşan programlar için kullanılabilir. İlk safhada yazılım ürününün ilk sürümünü geliştiriyoruz. Direkt olarak yazılım ürünü gerçekleştirilir. Sistem,en son istenilen şekle gelinceye kadar devamlı geliştirilir. Bakım safhası var ama çok zor. Çünkü sisteme ait dokümantasyon yok. Ayrıca emeklilik (retirement) safhası var. Yazılım geliştirmenin en kolay yoludur. Yazılım geliştirmek kolay olduğu için ne yazıkki küçük firmalardaki (yada tecrübesiz)birçok yazılım projesinde bu model kullanılır. Bu modelin avanatajarı, herhangi bir planlamaya ihtiyaç duyulmaz. Çok küçük  projelerde ya da kısa ömürlü prototiplerde uygulanabilir. Program aşamaları çabuk geçilir. Uzman görüşüne ihtiyaç düşüktür, herkes bu modeli kullanabilir. Dezavantajları, kontrollü değildir. Kaynak planlaması yoktur. Bitiş süresi belli değildir .Hataların bulunması ve doğrulanması zordur. Kodları düzeltmek maliyetli olabilir.(En pahalı yazılım geliştirme modelidir.) Kodlamadan sonra bir yazılım ürünündeki değişikliklerin maliyetini düşünürsek, bu maliyet çok yüksektir. Ayrıca, şartname ve tasarım dokümanı olmaksızın, ürünün bakımını yapmak fazlasıyla zordur. Kodlar kullanıcının ihtiyacını karşılamayabilir. Kodlar sonradan değiştirmek için planlanmadığından esnek değildir  ve değiştirilmesi zordur.
 
 SCRUM NEDİR?
 
Zaman içerisinde projelerin daha büyük ve karmaşık bir hal alması, bununla beraber müşterinin büyük resmi göremeyip gereksinimlerini tam olarak ortaya koyamaması, teknolojinin çok hızlı değişmesi ile beraber gereksinimlerin çabuk değişmesi ve bunu projemize entegre edemeyişimiz gibi problemlerden dolayı çoğu proje başarısızlık ile sonuçlanmaya başladı. Böylece proje sürecinin yönetilmesi konusu önemli bir konu oldu ve “Çevik (Agile) Yazılım Geliştirme Manifestosu” ortaya çıktı.Çevik (Agile) Yazılım Geliştirme Manifestosu, süreçten ziyade bireylerin daha etkileşimli olmalarına, kapsamlı dökümantasyonlardan ziyade çalışan yazılıma, sözleşme pazarlığından ziyade müşteri ile işbirliğine, bir plana bağlı kalmaktan ziyade değişime karşılık vermeye dayanır. Böylece değişen gereksinimler projenin son aşamasında bile kabul edilebilir oldu, daha kısa süreli bildirimler ile hata payı azaltıldı ve çalışan yazılım müşteriye sunuldu, iş sahibi ve yazılımcılar süreç boyunca birlikte çalıştı, yüz yüze iletişime dayandığı için bilgi alışverişi sağlandı. Scrum; Scrum adı, Rugby sporundaki bir hücum taktiğinin adıdır.Bu taktikte top, tüm oyuncularla birlikte karşı sahaya taşınarak atak yapılmaktadır. Agile proje yönetim metodolojilerinden biridir. Kompleks yazılım süreçlerinin yönetilmesi için kullanılır. Bunu yaparken bütünü parçalayan; tekrara dayalı bir yöntem izler. Düzenli geri bildirim ve planlamalarla hedefe ulaşmayı sağlar. Bu anlamda ihtiyaca yönelik ve esnek bir yapısı vardır. Müşteri ihtiyacına göre şekillendiği için müşterinin geri bildirimine göre yapılanmayı sağlar. İletişim ve takım çalışması çok önemlidir. 3 temel prensip üzerine kurulmuştur:Şeffaflık; Projenin ilerleyişi, sorunlar,gelişmeler herkes tarafından görülebilir olmalıdır.Denetleme; Projenin ilerleyişi düzenli olarak kontrol edilir.Uyarlama; Proje, yapılabilecek değişikliklere uyum sağlayabilmelidir.

SCRUM YAPISI

1)Product Backlog; Proje için gerekli olan gereksinimler listesidir. Proje sonunda “Ne üretilmek isteniyor?” sorusuna cevap aranır. Product owner tarafından müşteriden gereksinimler alınır, öncelik sırasına göre sıralanır. Product owner, değişen ihtiyaçlara göre product backloga ekleme veya çıkarma yapabilir. Böylece değişim, projenin her aşamasında projeye kolayca entegre edilebilir olur.
2)Product Backlog Item; Product backlog içindeki her bir gereksinime verilen isimdir.
3)Sprint(Koşma); Proje sprint denilen küçük kısımlara ayrılır. Scrum içerisindeki tüm aktiviteler sprint içerisinde gerçekleşir.1–2 haftalık süreçlerdir.
4)Sprint Backlog; Geliştirme takımı tarafından product backlog itemlar öncelik sırasına göre sprint içerisine alınırlar. Bir sprint boyunca yapılacak itemların listesini oluşturur. İşlerin detaylı olarak zaman çizelgesi çıkarılır.
5)Scrum board; Bir sprint içerisinde yapılacak olan maddeler burada yönetilir. Yapılacak olan tasklar “TO DO” bölümüne alınır. Takım üyesi bu işe başladığında “IN PROGRESS” bölümüne getirilir. Bir iş, test için hazırsa “TO VERIFY” durumuna getirilir. İş, kontrol edildikten sonra “DONE” bölümüne getirilir. Scrum toplantılarında bu maddeler durumlarına göre yerleri değiştirilir.
6)Burndown Chart; Yatay ekseninde sprintin günlerini, dikey ekseninde sprintte kalan işi gösteren grafiktir. Scrum’un temel ilkelerinden olan şeffaflığı sağlar.

ROLLER

Pig Roller; Scrum sürecine dahil olanlar yani projede asıl işi yapan kişilerdir. Bunlar Scrum Master, Product Owner, Geliştirme Takımı’dır.
1) Product Owner; Geliştirme takımı ve müşteri arasındaki iletişimi sağlar. Projenin özelliklerini tanımlar. Projenin önceliklerine göre product backlogu oluşturur. Sprint’i iptal yetkisine sahiptir. Sprint neden iptal edilmek istenebilir? Hızla değişen ortamlarda bir sprinte alınan işlerin iş birimi için önemi kalmamış olabilir ya da sprinte alınan işlerden daha önemli işler ortaya çıkabilir. İş sahibi bunu görüp sprinti iptal etmek isteyebilir.
2) Scrum Master; Scrum kurallarını, teorilerini ve pratiklerini iyi bilir ve takımın bu kurallarını uygulamasından sorumlu kişidir. Takımın yöneticisi değildir. Takımı rahatsız eden, verimli çalışmalarını engelleyen durumları ortadan kaldırır.
3) Geliştirme Takımı; Bir Sprint’e alınan bütün işleri tamamlayacak özelliklere sahip kişilerdir. sprint backlogu oluştururlar. Kendi kendini yönetir. İşin verilmesini beklemezler, işi kendileri alır ve geliştirirler. Kişilerin tek bir görevi yoktur, çapraz görev dağılımı yaparlar, herkes her şeyi yapabilir konumdadır. 5–7 kişi arasında değişir. Projenin geliştirilmesi ile ilgili sorumluluk geliştirme takımına aittir.
Chicken Roller; Scrum’ın işleyişinde aktif olarak yer almayan kişilerdir. Müşteriler, satıcılar gibi.

TOPLANTILAR

1) Sprint Planning; Product backlog ile belirtilen gereksinimler, bu toplantı ile geliştirme takımı tarafından küçük görevlere (task) ayrılır. Takımdaki her bir kişi kendi hızına göre bu taskleri kendilerine alır. Bu toplantıya product owner, geliştirme takımı ve scrum master katılır. Sprintler; her sprint sonunda product owner a sunulmak üzere yazılım geliştirmeyi hedefleyecek şekilde belirlenir.1–3 haftalık sprintler oluşturulur.
2) Daily Scrum; Her gün aynı yerde aynı saatte ayak üstü yapılan 15 dakikalık toplantılardır. Üyeler davet edilmeyi beklemezler. Bu toplantı gelecek 24 saati planlamak üzere yapılır. Takımdaki her üye dün ne yaptım,bugün ne yapacağım, işimi engelleyen herhangi bir sorun var mı sorularına cevap verir. Bu sayede herhangi bir sorunu var ise scrum master bu problemi ortadan kaldırır. Takım üyelerinden bu probleme yardımcı olabilecek biri var ise toplantı sonunda iletişime geçebilirler. Daily scrum her ne koşulda olursa olsun yapılır. Takımdaki birinin geç kalması veya gelmemesi toplantıyı etkilemez. Sadece takımdaki büyük çoğunluk yok ise toplantı yapılmaz.
3)Sprint Review; Her sprint sonunda yapılır. Yapılan sprint gözden geçirilir, ortaya çıkan ürün değerlendirilir. Amaç yazılımın ürün sahibinin gereksinimlerine uygun olarak geliştirildiğinden emin olmaktır. Eğer bir hata var ise farkedilir ve düzeltilir.
4)Sprint Retrospective; Sprint boyunca yapılan işlerin kalitesinin, doğruların ve yanlışların değerlendirildiği toplantıdır. Bu toplantı scrum takımının kendini geliştirebilmesi için bir fırsattır. “Neleri daha iyi yapabiliriz?”, “Nasıl daha iyi yapabiliriz?” sorularına cevap aranır. Bu aşamadan sonra bir sonraki sprint planning toplantısı gerçekleştirilerek yazdıklarımızın hepsi tekrardan yaşanır.

SCRUM NEDEN POPÜLER?

Kısaca Scrum, çalışanların karmaşık sorunları doğru biçimde ele alırken, bir yandan da yüksek değere sahip üretim yapmaları hedefleyen bir çerçevedir. Scrum, bu verimli üretimin yaratıcı ve sorun çözümünün adaptasyona açık olmasını da teşvik eder.














                                                                                                                                İREM KARADAĞ-210601051

KAYNAKÇA
https://www.javatpoint.com/software-engineering-sdlc-models
https://www.inflectra.com/SpiraTeam/?utm_source=GoogleAd&gclid=EAIaIQobChMIjcme88fU9gIVpZBoCR2X5AStEAAYASAAEgLZR_D_BwE
https://medium.com/@tunaytoksoz/yazilim-ya%C5%9Fam-d%C3%B6ng%C3%BCs%C3%BC-sdlc-ve-modelleri%CC%87-c3fe40f6e4e8
https://www.softwaretestinghelp.com/software-development-life-cycle-sdlc/
https://www.roberthalf.com.au/blog/employers/6-basic-sdlc-methodologies-which-one-best
https://ubys.bakircay.edu.tr//AIS/Common/Content/PdfJs/web/viewer.html?file=https%3a%2f%2fubys.bakircay.edu.tr%2f%2fAIS%2fCommon%2fFile%2fGetEncryptedFileAsPDF%3fefai%3dNjBGKkTTLeovHAijlE7bVg!xGGx!!xGGx!
https://medium.com/@secilcor/scrum-nedi%CC%87r-6a4326951dd8
